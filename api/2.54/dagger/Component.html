<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (18) -->
<title>Component</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF8">
<meta name="description" content="declaration: package: dagger, annotation type: Component">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Component.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Field</li>
<li>Required</li>
<li><a href="#annotation-interface-optional-element-summary">Optional</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li><a href="#annotation-interface-element-detail">Element</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li><a href="#annotation-interface-optional-element-summary">Optional</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation-interface-element-detail">Element</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">dagger</a></div>
<h1 title="Annotation Interface Component" class="title">Annotation Interface Component</h1>
</div>
<section class="class-description" id="class-description">
<hr>
<div class="type-signature"><span class="annotations"><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/Retention.html" title="class or interface in java.lang.annotation" class="external-link">@Retention</a>(<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/RetentionPolicy.html#RUNTIME" title="class or interface in java.lang.annotation" class="external-link">RUNTIME</a>)
<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/Target.html" title="class or interface in java.lang.annotation" class="external-link">@Target</a>(<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/ElementType.html#TYPE" title="class or interface in java.lang.annotation" class="external-link">TYPE</a>)
<a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/annotation/Documented.html" title="class or interface in java.lang.annotation" class="external-link">@Documented</a>
</span><span class="modifiers">public @interface </span><span class="element-name type-name-label">Component</span></div>
<div class="block">Annotates an interface or abstract class for which a fully-formed, dependency-injected
 implementation is to be generated from a set of <a href="#modules()">modules()</a>. The generated class will
 have the name of the type annotated with <code>@Component</code> prepended with <code>Dagger</code>. For
 example, <code>@Component interface MyComponent {...}</code> will produce an implementation named
 <code>DaggerMyComponent</code>.

 <p><a id="component-methods"></a>

 <h2>Component methods</h2>

 <p>Every type annotated with <code>@Component</code> must contain at least one abstract component
 method. Component methods may have any name, but must have signatures that conform to either
 provision or <a href="MembersInjector.html" title="interface in dagger">members-injection</a> contracts.

 <p><a id="provision-methods"></a>

 <h3>Provision methods</h3>

 <p>Provision methods have no parameters and return an <code>injected</code> or <a href="Provides.html" title="annotation interface in dagger"><code>provided</code></a> type. Each method may have a <code>Qualifier</code> annotation as well. The following are
 all valid provision method declarations:

 <pre><code>
   SomeType getSomeType();
   Set&lt;SomeType&gt; getSomeTypes();
   @PortNumber int getPortNumber();
 </code></pre>

 <p>Provision methods, like typical <code>injection</code> sites, may use <code>Provider</code> or
 <a href="Lazy.html" title="interface in dagger"><code>Lazy</code></a> to more explicitly control provision requests. A <code>Provider</code> allows the user of
 the component to request provision any number of times by calling <code>Provider.get()</code>. A <a href="Lazy.html" title="interface in dagger"><code>Lazy</code></a> will only ever request a single provision, but will defer it until the first call to <a href="Lazy.html#get()"><code>Lazy.get()</code></a>. The following provision methods all request provision of the same type, but each
 implies different semantics:

 <pre><code>
   SomeType getSomeType();
   Provider&lt;SomeType&gt; getSomeTypeProvider();
   Lazy&lt;SomeType&gt; getLazySomeType();
 </code></pre>

 <a id="members-injection-methods"></a>

 <h3>Members-injection methods</h3>

 <p>Members-injection methods have a single parameter and inject dependencies into each of the
 <code>Inject</code>-annotated fields and methods of the passed instance. A members-injection method
 may be void or return its single parameter as a convenience for chaining. The following are all
 valid members-injection method declarations:

 <pre><code>
   void injectSomeType(SomeType someType);
   SomeType injectAndReturnSomeType(SomeType someType);
 </code></pre>

 <p>A method with no parameters that returns a <a href="MembersInjector.html" title="interface in dagger"><code>MembersInjector</code></a> is equivalent to a members
 injection method. Calling <a href="MembersInjector.html#injectMembers(T)"><code>MembersInjector.injectMembers(T)</code></a> on the returned object will
 perform the same work as a members injection method. For example:

 <pre><code>
   MembersInjector&lt;SomeType&gt; getSomeTypeMembersInjector();
 </code></pre>

 <h4>A note about covariance</h4>

 <p>While a members-injection method for a type will accept instances of its subtypes, only <code>Inject</code>-annotated members of the parameter type and its supertypes will be injected; members of
 subtypes will not. For example, given the following types, only <code>a</code> and <code>b</code> will be
 injected into an instance of <code>Child</code> when it is passed to the members-injection method
 <code>injectSelf(Self instance)</code>:

 <pre><code>
   class Parent {
     @Inject A a;
   }

   class Self extends Parent {
     @Inject B b;
   }

   class Child extends Self {
     @Inject C c;
   }
 </code></pre>

 <a id="instantiation"></a>

 <h2>Instantiation</h2>

 <p>Component implementations are primarily instantiated via a generated <a href="http://en.wikipedia.org/wiki/Builder_pattern">builder</a> or <a href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)">factory</a>.

 <p>If a nested <a href="Component.Builder.html" title="annotation interface in dagger"><code>@Component.Builder</code></a> or <a href="Component.Factory.html" title="annotation interface in dagger"><code>@Component.Factory</code></a> type
 exists in the component, Dagger will generate an implementation of that type. If neither exists,
 Dagger will generate a builder type that has a method to set each of the <a href="#modules()">modules()</a>
 and component <a href="#dependencies()">dependencies()</a> named with the <a href="http://en.wikipedia.org/wiki/CamelCase">lower camel case</a> version of the module or
 dependency type.

 <p>In either case, the Dagger-generated component type will have a static method, named either
 <code>builder()</code> or <code>factory()</code>, that returns a builder or factory instance.

 <p>Example of using a builder:

 <pre><code>
 public static void main(String[] args) {
   OtherComponent otherComponent = ...;
   MyComponent component = DaggerMyComponent.builder()
       // required because component dependencies must be set
       .otherComponent(otherComponent)
       // required because FlagsModule has constructor parameters
       .flagsModule(new FlagsModule(args))
       // may be elided because a no-args constructor is visible
       .myApplicationModule(new MyApplicationModule())
       .build();
 }
 </code></pre>

 <p>Example of using a factory:

 <pre><code>
 public static void main(String[] args) {
     OtherComponent otherComponent = ...;
     MyComponent component = DaggerMyComponent.factory()
         .create(otherComponent, new FlagsModule(args), new MyApplicationModule());
     // Note that all parameters to a factory method are required, even if one is for a module
     // that Dagger could instantiate. The only case where null is legal is for a
     // @BindsInstance @Nullable parameter.
   }
 </code></pre>

 <p>In the case that a component has no component dependencies and only no-arg modules, the
 generated component will also have a factory method <code>create()</code>. <code>
 SomeComponent.create()</code> and <code>SomeComponent.builder().build()</code> are both valid and
 equivalent.

 <p><a id="scope"></a>

 <h2>Scope</h2>

 <p>Each Dagger component can be associated with a scope by annotating it with the scope annotation. The component implementation ensures that there is only one provision of
 each scoped binding per instance of the component. If the component declares a scope, it may only
 contain unscoped bindings or bindings of that scope anywhere in the graph. For example:

 <pre><code>
   @Singleton @Component
   interface MyApplicationComponent {
     // this component can only inject types using unscoped or @Singleton bindings
   }
 </code></pre>

 <p>In order to get the proper behavior associated with a scope annotation, it is the caller's
 responsibility to instantiate new component instances when appropriate. A <code>Singleton</code>
 component, for instance, should only be instantiated once per application, while a <code>
 RequestScoped</code> component should be instantiated once per request. Because components are
 self-contained implementations, exiting a scope is as simple as dropping all references to the
 component instance.

 <p><a id="component-relationships"></a>

 <h2>Component relationships</h2>

 <p>While there is much utility in isolated components with purely unscoped bindings, many
 applications will call for multiple components with multiple scopes to interact. Dagger provides
 two mechanisms for relating components.

 <p><a id="subcomponents"></a>

 <h3>Subcomponents</h3>

 <p>The simplest way to relate two components is by declaring a <a href="Subcomponent.html" title="annotation interface in dagger"><code>Subcomponent</code></a>. A
 subcomponent behaves exactly like a component, but has its implementation generated within a
 parent component or subcomponent. That relationship allows the subcomponent implementation to
 inherit the <em>entire</em> binding graph from its parent when it is declared. For that reason, a
 subcomponent isn't evaluated for completeness until it is associated with a parent.

 <p>Subcomponents are declared by listing the class in the <a href="Module.html#subcomponents()"><code>Module.subcomponents()</code></a>
 attribute of one of the parent component's modules. This binds the <a href="Subcomponent.Builder.html" title="annotation interface in dagger"><code>Subcomponent.Builder</code></a>
 or <a href="Subcomponent.Factory.html" title="annotation interface in dagger"><code>Subcomponent.Factory</code></a> for that subcomponent within the parent component.

 <p>Subcomponents may also be declared via a factory method on a parent component or subcomponent.
 The method may have any name, but must return the subcomponent. The factory method's parameters
 may be any number of the subcomponent's modules, but must at least include those without visible
 no-arg constructors. The following is an example of a factory method that creates a
 request-scoped subcomponent from a singleton-scoped parent:

 <pre><code>
   @Singleton @Component
   interface ApplicationComponent {
     // component methods...

     RequestComponent newRequestComponent(RequestModule requestModule);
   }
 </code></pre>

 <a id="component-dependencies"></a>

 <h3>Component dependencies</h3>

 <p>While subcomponents are the simplest way to compose subgraphs of bindings, subcomponents are
 tightly coupled with the parents; they may use any binding defined by their ancestor component
 and subcomponents. As an alternative, components can use bindings only from another <em>component
 interface</em> by declaring a <a href="#dependencies()">component dependency</a>. When a type is
 used as a component dependency, each <a href="#provision-methods">provision method</a> on the
 dependency is bound as a provider. Note that <em>only</em> the bindings exposed as provision
 methods are available through component dependencies.</div>
<dl class="notes">
<dt>Since:</dt>
<dd>2.0</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static @interface&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="Component.Builder.html" class="type-name-link" title="annotation interface in dagger">Component.Builder</a></code></div>
<div class="col-last even-row-color">
<div class="block">A builder for a component.</div>
</div>
<div class="col-first odd-row-color"><code>static @interface&nbsp;</code></div>
<div class="col-second odd-row-color"><code><a href="Component.Factory.html" class="type-name-link" title="annotation interface in dagger">Component.Factory</a></code></div>
<div class="col-last odd-row-color">
<div class="block">A factory for a component.</div>
</div>
</div>
</section>
</li>
<!-- =========== ANNOTATION INTERFACE OPTIONAL MEMBER SUMMARY =========== -->
<li>
<section class="member-summary" id="annotation-interface-optional-element-summary">
<h2>Optional Element Summary</h2>
<div class="caption"><span>Optional Elements</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Optional Element</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;?&gt;[]</code></div>
<div class="col-second even-row-color"><code><a href="#dependencies()" class="member-name-link">dependencies</a></code></div>
<div class="col-last even-row-color">
<div class="block">A list of types that are to be used as <a href="#component-dependencies">component
 dependencies</a>.</div>
</div>
<div class="col-first odd-row-color"><code><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;?&gt;[]</code></div>
<div class="col-second odd-row-color"><code><a href="#modules()" class="member-name-link">modules</a></code></div>
<div class="col-last odd-row-color">
<div class="block">A list of classes annotated with <a href="Module.html" title="annotation interface in dagger"><code>Module</code></a> whose bindings are used to generate the
 component implementation.</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details" id="annotation-interface-element-detail">
<ul class="details-list">
<!-- ============ ANNOTATION INTERFACE MEMBER DETAIL =========== -->
<li>
<section class="member-details">
<h2>Element Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="modules()">
<h3>modules</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;?&gt;[]</span>&nbsp;<span class="element-name">modules</span></div>
<div class="block">A list of classes annotated with <a href="Module.html" title="annotation interface in dagger"><code>Module</code></a> whose bindings are used to generate the
 component implementation. Note that through the use of <a href="Module.html#includes()"><code>Module.includes()</code></a> the full set of
 modules used to implement the component may include more modules that just those listed here.</div>
<dl class="notes">
<dt>Default:</dt>
<dd>{}</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dependencies()">
<h3>dependencies</h3>
<div class="member-signature"><span class="return-type"><a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Class.html" title="class or interface in java.lang" class="external-link">Class</a>&lt;?&gt;[]</span>&nbsp;<span class="element-name">dependencies</span></div>
<div class="block">A list of types that are to be used as <a href="#component-dependencies">component
 dependencies</a>.</div>
<dl class="notes">
<dt>Default:</dt>
<dd>{}</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
